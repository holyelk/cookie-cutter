# Default values for backend-service.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.


# Enable or disable the application deployment. 
# Set to false if you only want to deploy the database keys or other components.
app:
  enabled: true

replicaCount: 2

image:
  repository: registry.gitlab.com/username/project
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: "latest"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

podSecurityContext:
  runAsNonRoot: true
  fsGroup: 2000

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: false # Set to true if possible, but python often writes pycache or logs to disk (configured to stdout here, but pycache might be issue)
  runAsNonRoot: true
  runAsUser: 1000

service:
  type: ClusterIP
  port: 80
  targetPort: 8000

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: Prefix
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

resources: 
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}

# Application specific environment variables
env:
  APP_NAME: "backend-service"
  ENVIRONMENT: "prod"
  LOG_LEVEL: "INFO"
  ENABLE_TELEMETRY: "true"
  OTLP_GRPC_ENDPOINT: "http://otel-collector:4317"

# PostgreSQL (CloudNativePG)
# PostgreSQL (CloudNativePG)
postgres:
  enabled: false
  name: "backend-db"
  instances: 3
  
  # Optional: specific image
  # imageName: ghcr.io/cloudnative-pg/postgresql:16.1
  
  storage:
    size: 10Gi
    class: standard

  # PostgreSQL Runtime Configuration
  postgresql:
    parameters:
      max_connections: "100"
      shared_buffers: "128MB"
      # log_min_duration_statement: "1000"

  # Resources for the Database Pods
  resources:
    requests:
      memory: "512Mi"
      cpu: "500m"
    limits:
      memory: "1Gi"
      cpu: "1000m"
  
  # Bootstrap strategy (initdb, recovery, or pg_basebackup)
  bootstrap:
    initdb:
      database: app
      owner: app
      # secret:
      #   name: my-password-secret

    # Example restore:
    # recovery:
    #   source: my-old-cluster

  # Backup Configuration
  backup:
    enabled: false
    retentionPolicy: "30d"
    # barmanObjectStore:
    #   destinationPath: s3://my-bucket/
    #   endpointURL: http://minio:9000
    #   s3Credentials:
    #     accessKeyId:
    #       name: backup-creds
    #       key: ACCESS_KEY_ID
    #     secretAccessKey:
    #       name: backup-creds
    #       key: SECRET_ACCESS_KEY
    
  # Affinity and Node Selection for DB
  affinity: {}
  nodeSelector: {}
  tolerations: []

  # Monitoring (Prometheus Operator)
  monitoring:
    enablePodMonitor: false


# Logical Backup (pg_dumpall to S3)
logicalBackup:
  enabled: false
  schedule: "0 2 * * *" # Daily at 2 AM
  image:
    repository: postgres
    tag: "16-alpine"
  s3:
    endpoint: "" # e.g. https://s3.amazonaws.com or http://minio:9000
    bucket: ""
    prefix: "backups/"
    region: "us-east-1"
  # Connection details (use if different from CNPG defaults)
  postgres:
    host: "" # Leave empty to auto-discover if postgres.enabled=true
    port: 5432
    user: "postgres" 
    database: "postgres"
  # Secrets for S3 and Postgres Password
  # Provide via existingSecret or use secrets map below
  existingSecret: "" # Secret containing AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, PGPASSWORD
  resources:
    limits:
      cpu: 500m
      memory: 256Mi
    requests:
      cpu: 100m
      memory: 128Mi

# Secrets (configured via CI --set secrets.KEY=value or values file not in git)
secrets: {}
